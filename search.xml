<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue-router 原理]]></title>
    <url>%2F2019%2F01%2F08%2Fvue%2FVue-router-%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、为什么可以实现前端路由1. hash 模式因为改变hash 值并不会导致页面的刷新，通过监听 window.onhashname去实现不跳转的页面切换。 2. history 模式14年后，html5 标准发布，通过两个api pushState 、 replaceState、popstate，去改变url 但不发送请求，但比起hash 模式 ，url 美观hh 通过 window.onpopstate = function(event){ }监听 前进后退]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 水平垂直居中小集合]]></title>
    <url>%2F2019%2F01%2F06%2Fcss%2FCSS-%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B0%8F%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[平常前端开发的时候经常遇到这样的问题，时不时就会忘记，今天就想一次性把所有 CSS居中 的方法进行总结，当做自己的备忘录 一、水平居中概括： 内联元素 text-v 块级元素 margin: 0px auto; 多块级元素，将块级元素设置为 inline-block,再通过 text-align flex 布局 justify-content: center 二、垂直居中概括：1.单行元素：height 和 line-height 设置一样的高度 table 布局，父元素设置 display: table ，子元素设置 display: table-cell; vertical-align: center flex 布局 align-center:center CSS3 transform 属性，结合绝对位置，实现垂直居中，部分浏览器会有兼容性问题12345678.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; transform: translateY(-50%);&#125; 三、水平+垂直 布局 flex 双重属性设置居中 table + 设置宽度+ margin 来完成（兼容性有较好的的保证） 未知宽高元素，通过 transform + absolute 123456789.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; 固定宽高——通过设置 absolute 和 margin 反向设置进行 grid 布局（不清楚后期补） 以下是上方部分的详细例子 二、垂直居中1. 单行内联元素垂直居中1234567891011121314&lt;style&gt; .main&#123; height: 200px; background-color: #fcc; overflow: hidden; line-height: 40px; font-size: 40px; &#125;&lt;/style&gt;&lt;template&gt; &lt;div class=&quot;main&quot;&gt; 我是一行 &lt;/div&gt;&lt;/template&gt; 通过 height line-height 配合进行垂直居中 line-height 属性设置行间的距离（不允许为负值） 这个距离是两行之间基线的举例，看下图会很清楚 定义height 的五种方式： 1.line-height可以被定义为：body{line-height:normal;} 2.line-height可以被定义为：body{line-height:inherit;} 3.line-height可以使用一个百分比的值body{line-height:120%;} 4.line-height可以被定义为一个长度值(px,em等) body{line-height:25px;} 5.line-height也可以被定义为纯数字， body{line-height:1.2}—————会通过font-size 自动进行调节 更详细的例子在这里查看 深入了解css的行高Line Height属性 2.多行垂直居中1234567891011121314151617181920&lt;style&gt; .table&#123; display: table; background-color: #4cd1d4; height: 150px; &#125; .cell&#123; display: table-cell; vertical-align: middle; &#125;&lt;/style&gt;&lt;template&gt; &lt;div class=&quot;table&quot;&gt; &lt;div class=&quot;cell&quot;&gt; 我是一行 &lt;br&gt; 我是二行 &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 3. Flex 布局通过设置 flex 布局的交叉轴方向即可 align-items: center12345678910111213&lt;style&gt; .flexStyle&#123; display: flex; align-items: center; height: 100px; background-color: gray; &#125;&lt;/style&gt;&lt;template&gt; &lt;div class=&quot;flexStyle&quot;&gt; flex 布局 &lt;/div&gt;&lt;/template&gt; 三、水平垂直居中###1. 未知宽高元素水平垂直居中利用 2D 变换123456789.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; 利用 flex 布局设置 主轴方向 justify-content 和 交叉轴方向 align-center （也就是纵轴）为 center 就可以达到居中 table布局结合开始 table 垂直居中，外层设置 display:table，内层设置 display: table-cell;vertical: center，最后在通过水平垂直的方法完成 引用参考 CSS line-height概念与举例 深入了解css的行高Line Height属性 这15种CSS居中的方式，你都用过哪几种？]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[习惯的力量——音频记录+感想]]></title>
    <url>%2F2019%2F01%2F05%2F%E8%AE%A4%E7%9F%A5%2F%E4%B9%A0%E6%83%AF%E7%9A%84%E5%8A%9B%E9%87%8F%2F</url>
    <content type="text"><![CDATA[一、习惯是怎么运作 需要一个暗示 是要有一个惯常行为 得到奖赏 二、 如何养成新习惯秘诀：找到一个合适的暗示，加一个习惯养成的奖赏，培养对这种奖赏的渴望 比如： 完美身材，想象当你走在街上，别人对你身材投来的羡慕目光时，你就会对好身材产生渴求感，这种感觉会让你更想去健身，从而养成习惯。（其实也就是一个反馈） 自我理解： 习惯是简化人思考的一种方式，减少人的消耗。 养成一个习惯需要一个长期的反馈机制，也就是上文所说奖赏的渴望]]></content>
      <categories>
        <category>Learning_Method</category>
      </categories>
      <tags>
        <tag>Learing_Method</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript常见用法]]></title>
    <url>%2F2018%2F12%2F15%2Fjavascript%2FsetTimout%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[记录常见容易入坑的 JavaScript 用法 1.setTimeout / setInterval 中的函数 this 指向 window下面这个例子可以看出，setInterval/setTimout 中的传入函数中的 this 会指向 window 对象 1234567891011var a = 1;function time()&#123; this.a = 2 ; this.getA = function()&#123; setInterval(function()&#123; console.log(this.a); &#125;,1000); &#125;&#125;var t = new time();t.getA() // 不断的打印出： 1 问题解析：setTimeout / setInterval 中的函数运行环境并不是当前执行环境，导致 this 指向 window 对象，详细可以看 MDN setTimeout 解决方法： 在当前对象中设定一个新变量 that 指向原来的 this 123456789101112var a = 1;function time()&#123; this.a = 2 ; var that = this; this.getA = function()&#123; setInterval(function()&#123; console.log(that.a); &#125;,1000); &#125;&#125;var t = new time();t.getA() // 不断的打印出： 2 通过 bind 方式设置作用域 1234567891011var a = 1;function time()&#123; this.a = 2 ; this.getA = function()&#123; setInterval(function()&#123; console.log(this.a); &#125;.bind(this),1000); &#125;&#125;var t = new time();t.getA() // 不断的打印出： 2 通过箭头函数，该方法 this 总是指向外层调用者的 this 1234567891011var a = 1;function time()&#123; this.a = 2 ; this.getA = function()&#123; setInterval(()=&gt;&#123; console.log(this.a); &#125;,1000); &#125;&#125;var t = new time();t.getA() // 不断的打印出： 2]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3 动画]]></title>
    <url>%2F2018%2F12%2F12%2Fcss%2Fcss3-%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[今天终于发现这个神奇的操作了，transition ，今天深入了解了下，只要在当前的样式中设置了 transition，未来如果对当前 dom 的样式进行更改，则会通过 transition 进行样式的过渡，非常的顺滑，下面就对方法进行记录 一、CSS3 变形transform 属性的的基本语法如下 `transform: none | 2D transform 常用的 transform-function 的功能： 函数 功能描述 translate() 移动元素，根据X轴和Y轴坐标重新定位元素位置，扩展函数有 translateX() , translateY() scale() 缩小或放大元素 rotate() 2d 旋转元素 skew() 元素倾斜，在此基础上扩展 skewX() , skewY() matrix() 定义矩阵变形 3D transform 常用的 transform-function 的功能 函数 功能描述 translate3d() 指定一个3D变形移动位移量 translateZ() 在 Z 轴上的位移 scale3d(sx,sy,sz) 放大、缩小 scaleZ(s) rotate3d(x,y,z,a) x,y,z 分别为绕各轴的矢量值（0-1的数值），a为角度值__3d旋转 rotateX()、rotateY()、rotateZ() perspective() 透视投影，值越大角度出现的越远，值越小，角度出现的越近,transform: perspective(300px) matrix3d() 二、CSS3 过渡 —— transitiontransition: 相当于 transition: &lt;过渡属性&gt; &lt;过渡所需时间&gt; &lt;过渡动画函数&gt; &lt;过渡延迟时间&gt; 1、过渡属性指定某一种 css 样式进行过渡 例： transition-property: all || none || width || background-color ….基本的css 样式都能 3、过渡动画函数该属性指定某种指点过渡 ”]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长回文序列]]></title>
    <url>%2F2018%2F12%2F10%2Fleetcode%2F%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: 123Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. Example 2: 12Input: &quot;cbbd&quot;Output: &quot;bb&quot; 回文需要分为奇数和偶数列 然后分为两层循环，一层为字符循环，一层为长度循环 主要关键点为边界条件，奇数列循环时的需要考虑前后边界 以及要考虑 偶数列的话，要排除特殊情况（ccc 的回文序列为 cc ，在欧数列中需要进行设置） 12345678910111213141516171819202122232425262728293031323334353637/** * @param &#123;string&#125; s * @return &#123;string&#125; */var longestPalindrome = function(s) &#123; var arr = s.split(''); var start = 0, end = 0; for(let i = 0; i&lt; arr.length; i++)&#123; for(let j = 1; j &lt;= i &amp;&amp; i + j &lt; arr.length; j++)&#123; if(arr[i-j] == arr[i+j])&#123; if( 2 * j &gt; end - start)&#123; start = i - j; end = i + j; &#125; else continue; &#125; else break; &#125; if(i &lt; arr.length - 1 &amp;&amp; arr[i] == arr [i+1])&#123; if(end - start &lt; 2)&#123; start = i; end = i + 1; &#125; for(let j = 1; j &lt;= i &amp;&amp; i + j +1 &lt; arr.length; j++)&#123; if(arr[i-j] == arr[i +j +1])&#123; if(2 * j + 2 &gt; end - start +1)&#123; start = i - j; end = i + j + 1; &#125; else continue; &#125; else break; &#125; &#125; &#125; return s.substring(start,end + 1);&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 滚动操作]]></title>
    <url>%2F2018%2F12%2F10%2Fjavascript%2Fjavascript-%E6%BB%9A%E5%8A%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[今天在使用 vonic 的时候，因为适配的组件的 position: absolute 然后发现 window.scrollTop 这东西， 下面就想深入了解，然后发现，所有的dom 元素都有 scrollTop scrollHeight clientHeight 等属性，所以可以直接通过 scrollTo() 方法直接设置 scrollTop JS监听滚动监听12345678910111213141516window.addEventListener('scroll',fun()) //添加滚动监听时间也可以对一个 dom 元素进行监听&lt;style&gt;.app&#123; height: 100px; overflow: scroll;&#125;&lt;/style&gt;&lt;div class="app" id='scroll'&gt; &lt;table&gt; &lt;/table&gt;&lt;/div&gt;document.getElementById.scrollTo(x,y) //可以直接设定里面元素scroll中的位置 ​]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3. longest Substring Without Repeating Characters--Medium]]></title>
    <url>%2F2018%2F12%2F07%2Fleetcode%2F3-longest-Substring-Without-Repeating-Characters-Medium%2F</url>
    <content type="text"><![CDATA[3. longest Substring Without Repeating Characters–MediumGiven a string, find the length of the longest substring without repeating characters. Example 1: 123Input: &quot;abcabcbb&quot;Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2: 123Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1. Example 3: 1234Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. 另一个大佬的写法，看看，其实这道题并不难，你的出发点有错误而已，不要自以为的认为某种方法慢，对其进行分析 方式一：在主要通过 flag 判断当前开始位置，通过 indexOf(searchIndex,fromIndex) 从flag 位置开始寻找是否有相同的字符，若有则改变 flag ，并判断是否修改最大值。 12345678910111213141516/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123; if (!s.length) return 0; var max = 1, flag = 0 for(var i = 0; i &lt; s.length; i++) &#123; var index = s.indexOf(s[i], flag) if (index !== -1 &amp;&amp; index &lt; i) flag = index + 1; //也可写为 if(index&lt;i),因为index 一定存在，并且 max = Math.max(max, i - flag + 1) &#125; return max&#125;; 方式二：通过一个 str存储字符串，cache 数组存储数组位置 当字符在 cache 中不存在时，则往 str 加入该字符和 cache 中加入以其字符为key、坐标为值的该字符对象。 当字符存在时： 先判断与最大值的长度比较 获取当前字符的位置 对 str 字符进行截取（从 index+1 开始) 12345678910111213141516171819202122232425262728293031323334/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123; var max = 0; var str = ''; var i = 0; var cache = []; while (i &lt; s.length) &#123; if (cache[s[i]]) &#123; // Found a repeating character. if (str.length &gt; max) &#123; max = str.length; &#125; var start = str.indexOf(s[i]); str = str.substring(start + 1); &#125; if (i &lt; s.length) &#123; str += s[i]; cache[s[i]] = i + 1; i++; &#125; &#125; if (str.length &gt; max) &#123; max = str.length; &#125; return max;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[速读笔记]]></title>
    <url>%2F2018%2F12%2F07%2F%E8%AE%A4%E7%9F%A5%2F%E9%80%9F%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[速读学习阅读关键 通过标题理解主要内容 缩短视觉定焦时间 加大视觉幅度（视幅） 阅读技能： 防止回调阅读 通过视读进行阅读 六个大坑 速读不是阅读完就会的，需要可以练习，至少学习 6 周才能掌握 速读不是省略的阅读，而是加快速度的逐句阅读 速读并不是聪明人的专利，而是人人都能掌握基础技能 速读不是稀释理解能力的阅读，而是脑力全开的阅读方式 速读不是一直保持一种速读，而是一种变速阅读方式 练习速读是一种科学的速读套路 自己理解： 需要可以训练 每个人都能掌握 尽可能的利用大脑 一、技能篇 001 谨记四要素16个字： 刻意拉伸、专项训练、及时反馈、全身关注 为什么牛逼的人能坚持，因为都是有反馈呀！ 所以训练的时候需要进行记录，让自己看得到进步，得到正反馈。 二、技能篇002 眼球运动训练锻炼眼部肌肉 手指引导法（因为人的眼睛是不会走直线） 通过 三、技能篇003 基础技能模块二： 视觉定焦训练 符号训练法 有节奏的默念法 手指刷页法————推荐 图解电影翻页法 四、技能篇004 基础技能模块三： 视觉幅度训练1. 语义单元法——重点笨鸟真的不一定先飞，因为可能你花费的时间的效率可能远远不足人家。 当你的大脑看了半分钟的文字后还没能了解当前文章的大意，大脑就是懈怠（人类的大脑是世界上最强大的超级计算机，会进行罢工 2. 立体图法3. 字母树法]]></content>
      <categories>
        <category>Learning_Method</category>
      </categories>
      <tags>
        <tag>Learing_Method</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[比较运算符]]></title>
    <url>%2F2018%2F12%2F05%2Fjavascript%2F%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[比较运算符 数字 跟 字符串 比较， 会将字符串转换成数字进行比较 字符串 和 字符串 比较，会比较对应位置上的字符 unicode 编码值比较 123&apos;a&apos;&lt; &apos;b&quot; //true&apos;abcdd&apos;&lt;&apos;abcda&apos; //false&apos;2018-02-23&apos;&lt;&apos;2018-11-11&apos; //true 详细记录 https://www.jeffjade.com/2015/08/28/2015-09-02-js-string-compare/]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[26. Remove Duplicates from Sorted Array]]></title>
    <url>%2F2018%2F12%2F05%2Fleetcode%2F26.%20Remove%20Duplicates%20from%20Sorted%20Array%2F</url>
    <content type="text"><![CDATA[26. Remove Duplicates from Sorted ArrayGiven a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: 12345Given nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.It doesn&apos;t matter what you leave beyond the returned length. Example 2: 12345Given nums = [0,0,1,1,1,2,2,3,3,4],Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn&apos;t matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: 12345678// nums is passed in by reference. (i.e., without making a copy)int len = removeDuplicates(nums);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解题思路： 通过两个变量来控制整个的替换， 1234567891011121314151617181920212223242526/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var removeDuplicates = function(nums) &#123; // if(nums == null || nums.length == 0) return []; // var answer = nums.reduce(function(prev,cur)&#123; // if(prev.indexOf(cur)==-1)&#123; // prev.push(cur); // console.log(prev); // &#125; // return prev; // &#125;,[]) // console.log(answer instanceof Array,nums); // return answer; var a = 0 ; for(var i=1;i&lt;nums.length;i++)&#123; if(nums[a]!= nums[i])&#123; a++; nums[a] = nums[i]; &#125; &#125; nums.splice(a+1,nums.length-a+1); return i;&#125;; 其他人解法 12345678910111213141516171819202122javascript/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */function removeD(sortedArray) &#123; if (sortedArray.length == 0) &#123; return 0 &#125; let i = 1 let j = 1 while(j &lt; sortedArray.length) &#123; if (sortedArray[j] != sortedArray[j-1]) &#123; sortedArray[i] = sortedArray[j] i++ &#125; j++ &#125; return i&#125; 数组操作一、splice 操作原文链接： http://caibaojian.com/js-splice-element.html 删除的数组的某一项splice(index,len,[item]) 注释：该方法会改变原始数组。 splice有3个参数，它也可以用来替换/删除/添加数组内某一个或者几个值 index:数组开始下标 len: 替换/删除的长度 item:替换的值，删除操作的话 item为空 来源： 前端开发博客 二、 Array.reduce()数组 reduce 用法 详解，后期记录 主要是设定初始值的时候格式 array.reduce(function(prev,cru,index,array){ },initialValue) initialValue 可以设置初始值 三、sort() 方法1.sort() 不带参数sort()方法对数组的元素做原地的排序，并返回这个数组。 它是按升序排列数组项。sort()方法会调用每个数组项的 toString() 转型方法，然后按 UNICODE 进行比较，然后根据这个进行排序 来一个简单的例子： 12var a = ['laoluo','kerwin','brady'];console.log(a.sort()); //数组顺序将变为 brady kerwin laoluo 12var 这num = [1,2,8,12,36];a.sort() // 数组顺序改成 1 12 2 36 8 通过charCodeAt()来验证一下 123"laoluo".charCodeAt() // 108"kerwin".charCodeAt() // 107"brady".charCodeAt() // 98 2. sort()中带参数——自己定义排序的函数可以在参数中定义一个比较函数 12345678910111213141516171819202122function compareFun(a,b)&#123; if(a&lt;b)&#123; return -1; // a 排在 b 的前面 &#125;else if(a&gt;b)&#123; return 1; // a 排在 b 后面 &#125;else&#123; return 0; // a和b的位置保持不变 &#125;&#125;//改良版function compareNew(a,b)&#123; return a&lt;b?-1:a&gt;b?1:0;&#125;//新版本升序function ascSort(a,b)&#123; return a - b;&#125;//新版本降序function desSort(a,b)&#123; return b-a;&#125; 通过以下的方式可以对数组进行正确的进行升序排序 12var c = [7,3,5,9,10,4];c.sort(compareFun); // c 数组将改变为 3,4,5,7,9,10 3. 数组随机排序123function randomSort(a,b)&#123; return Math.random() - 0.5;&#125; 更多的方法请参照 https://www.w3cplus.com/javascript/array-part-4.html]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2. Add Two Numbers——medium]]></title>
    <url>%2F2018%2F12%2F05%2Fleetcode%2F2.%20Add%20Two%20Numbers%E2%80%94%E2%80%94medium%2F</url>
    <content type="text"><![CDATA[2. Add Two Numbers——medium You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: 123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 这道题并不难： 其实就是通过进位进行设置而已。 把握好一些边界条件。当两个链表长度不等怎么办，最后一位含有进位如何 三个步骤: 判断节点 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var addTwoNumbers = function(l1, l2) &#123; var h1 = l1; var h2 = l2; var l3 = new ListNode(0); var current = l3; var carry = 0; while (h1 !== null || h2 !== null) &#123; var x = h1 !== null ? h1.val : 0; var y = h2 !== null ? h2.val : 0; var sum = x + y + carry; carry = Math.floor(sum/10); current.next = new ListNode(sum % 10); current = current.next; if(h1 !== null) &#123;h1 = h1.next&#125;; if(h2 !== null) &#123;h2 = h2.next&#125;; &#125; if (carry &gt; 0) &#123; current.next = new ListNode(carry); &#125; return l3.next;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript 循环集合]]></title>
    <url>%2F2018%2F12%2F05%2Fjavascript%2Fjavascript%20%E5%BE%AA%E7%8E%AF%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Javascript 循环集合在使用数组的时候经常用到循环，为了避免用最为简单的循环方法，现在整理下各种新型循环的方法 一、foreach()12345var arr = [1,2,3,'lala'];arr.forEach(function(value)&#123; console.log(value);&#125;)//输出 1 2 3 lala 小缺点： 不能使用 break 语句进行终端，也不能用 return 返回到外层函数 二、for in12345678910var arr = [1,2,3,&apos;lala&apos;];arr.__proto__.name = &apos;laoluo&apos;; //给 arr 的原型赋予属性namefor(let i in arr)&#123; console.log(i,arr[i]);&#125;// 0 1// 1 2// 2 3// 3 lala// name laoluo 上述代码中，赋给 i 的值并不是数字，而是字符串 ”0“、”1“、”2”、“3” ，此时很可能无意中对其进行字符串操作。例如 “2” + 1 = “21”，会对编码造成极大的不便 for-in 循环体除了遍历数组元素外，还会遍历自定义元素，如果数组中存在可枚举的属性 arr.name ,循环会将额外循环一次，遍历到名’name’的索引。就连数组的原型链上的属性也能被访问到 最令人震惊的是，这段代码可能按随机顺序遍历数组元素！！ 所以，for-in 是为普通对象进行设计的，可以遍历到对象的字符串类型的键值，因此不适用于数组 三、for of 循环这是最简洁的循环数组的语法 避开了 for-in 的全部缺陷 与 forEach 不同的是，他可以正确的响应 break、continue、return 语句 for-of 循环支持数组循环，还支持字符串的循环 1234567var arr = [1,2,3,5,6];for(let val of arr)&#123; console.log(val) // 分别输出 1 2 3 5 6&#125;for(let val of "laoluo")&#123; console.log(val); //分别输出各个字符 l a o l u o&#125; for-of 循环可以遍历其他集合（map， set）引用 https://www.infoq.cn/article/es6-in-depth-iterators-and-the-for-of-loop]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[717. 1-bit and 2-bit Characters]]></title>
    <url>%2F2018%2F12%2F05%2Fleetcode%2F717.%201-bit%20and%202-bit%20Characters%2F</url>
    <content type="text"><![CDATA[717. 1-bit and 2-bit Characters We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11). Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero. Example 1: 12345Input:bits = [1, 0, 0]Output: TrueExplanation:The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character. Example 2: 12345Input:bits = [1, 1, 1, 0]Output: FalseExplanation:The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character. Note: 1 &lt;= len(bits) &lt;= 1000. bits[i] is always 0 or 1. 解题思路: 由于只有三种编码方式 0 10 `11 所以只要遇到 1就会前进两格，当遇到0时则前进一格，令初始值为 i=0 如果最后一个为 0则倒数第二个数所积累的长度必然等于 length-1 123456789101112131415/** * @param &#123;number[]&#125; bits * @return &#123;boolean&#125; */var isOneBitCharacter = function(bits) &#123; var len = bits.length; var i = 0; while(i&lt;len-1)&#123; if(bits[i]=="1") i = i+2; else i++; &#125; return i == len-1&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[53. Maximum Subarray（最大子串）——EASY]]></title>
    <url>%2F2018%2F12%2F05%2Fleetcode%2F53.%20Maximum%20Subarray%EF%BC%88%E6%9C%80%E5%A4%A7%E5%AD%90%E4%B8%B2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[53. Maximum Subarray（最大子串）——EASYGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: 123Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6. Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. 解题思路： 从前往后进行遍历，设置两个总和 maxSum 和 curSum 当加上当前值小于之前值时，则替换最大值为当前值。 其实简单来说： 从前往后遍历，需要两个变量，一个max 存储最大值，一个 lastMax 存储当前最大值， 开始给 max 赋值 nums[0] . lastMax = 0; 然后不断的给 lastMax 赋值，如果大于 max 则进行替换 max，否则不变。 然后保证每次循环检验 lastMax 是否小于 0 ，如果小于0，则说明前面数并没起到作用，所以抛弃，lastMax 从0 开始。 1234567891011121314151617var maxSubArray = function(nums) &#123; if(nums.length==0) return 0; var maxSum = nums[0], curSum = nums[0]; for(var i=1;i&lt;nums.length;i++)&#123; if(nums[i]&gt;curSum+nums[i])&#123; curSum = nums[i]; &#125;else&#123; curSum += nums[i]; &#125; if(curSum&gt;maxSum)&#123; maxSum = curSum; &#125; &#125; return maxSum;&#125;;console.log(maxSubArray([-2,1,-3,4,-1,2,1,-5,4])); 另外一种写法 1234567891011121314var maxSubArray = function(nums) &#123; var max = nums[0]; var lastMax = 0; for(let i=0;i&lt;nums.length;i++)&#123; lastMax += nums[i]; if(lastMax&gt;max)&#123; max = lastMax; &#125; if(lastMax&lt;0)&#123; lastMax = 0; &#125; &#125; return max;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[942. DI String Match]]></title>
    <url>%2F2018%2F12%2F05%2Fleetcode%2F942.%20DI%20String%20Match%2F</url>
    <content type="text"><![CDATA[942. DI String Match Given a string S that only contains “I” (increase) or “D” (decrease), let N = S.length. Return any permutation A of [0, 1, ..., N] such that for all i = 0, ..., N-1: If S[i] == &quot;I&quot;, then A[i] &lt; A[i+1] If S[i] == &quot;D&quot;, then A[i] &gt; A[i+1] Example 1: 12Input: &quot;IDID&quot;Output: [0,4,1,3,2] Example 2: 12Input: &quot;III&quot;Output: [0,1,2,3] Example 3: 12Input: &quot;DDI&quot;Output: [3,2,0,1] Note: 1 &lt;= S.length &lt;= 10000 S only contains characters &quot;I&quot; or &quot;D&quot;. 123456789101112131415161718/** * @param &#123;string&#125; S * @return &#123;number[]&#125; */var diStringMatch = function(S) &#123; var min = 0; var max = S.length; var s = S.split(""); var answer = s.map(function(item)&#123; if(item=="I")&#123; return min++; &#125;else if (item=="D")&#123; return max--; &#125; &#125;) answer.push(min); //因为最后只剩下一个数字 return answer;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概念：浅拷贝-深拷贝]]></title>
    <url>%2F2018%2F12%2F05%2Fjavascript%2F%E6%A6%82%E5%BF%B5%EF%BC%9A%E6%B5%85%E6%8B%B7%E8%B4%9D-%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[概念：浅拷贝-深拷贝 浅拷贝，对于第一层目标对象为基本数据类型的数据，直接赋值，而对于引用数据类型，就是直接赋存在于栈内存的堆内存地址 ,即【传址】，并没有开辟新的栈 深拷贝，则为深度的赋值，里面对象对应两个var 三、深拷贝1.对象浅拷贝：(1) Object.assign({},yourObj); (2) var newObj = {…yourObj}; 2.对象深拷贝(1) JSON.parse(JSON.stringify(yourObject)) 后面再继续记录更多的方法 https://segmentfault.com/a/1190000015042902]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript字符串操作+ 929. Unique Email Addresses]]></title>
    <url>%2F2018%2F12%2F05%2Fleetcode%2FJavaScript%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%2B%20929.%20Unique%20Email%20Addresses%2F</url>
    <content type="text"><![CDATA[JavaScript字符串操作+ 929. Unique Email AddressesEvery email consists of a local name and a domain name, separated by the @ sign. For example, in `alice@leetcode.com,aliceis the local name, andleetcode.com` is the domain name. Besides lowercase letters, these emails may contain &#39;.&#39;s or &#39;+&#39;s. If you add periods (&#39;.&#39;) between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. For example, &quot;alice.z@leetcode.com&quot; and &quot;alicez@leetcode.com&quot; forward to the same email address. (Note that this rule does not apply for domain names.) If you add a plus (&#39;+&#39;) in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered, for example `m.y+name@email.comwill be forwarded tomy@email.com`. (Again, this rule does not apply for domain names.) It is possible to use both of these rules at the same time. Given a list of emails, we send one email to each address in the list. How many different addresses actually receive mails? Example 1: 123Input: [&quot;test.email+alex@leetcode.com&quot;,&quot;test.e.mail+bob.cathy@leetcode.com&quot;,&quot;testemail+david@lee.tcode.com&quot;]Output: 2Explanation: &quot;testemail@leetcode.com&quot; and &quot;testemail@lee.tcode.com&quot; actually receive mails Note: 1 &lt;= emails[i].length &lt;= 100 1 &lt;= emails.length &lt;= 100 Each emails[i] contains exactly one &#39;@&#39; character. 以上大概的意思就是检测是否有重复的邮箱，local部分如果有符号.则忽视，+则后面全部东西进行忽略 考点: 对字符串的操作 12345678910111213141516var numUniqueEmails = function(emails) &#123; var uniq = []; for (var i = 0; i &lt; emails.length; i++) &#123; var emSplit = emails[i].split('@'); var local = emSplit[0].split('+')[0].replace(/\./g, '') + '@' + emSplit[1]; var domain = emSplit[1]; //includes 是ES6 Array的新方法，查找是否有元素 if (!uniq.includes(local)) &#123; uniq.push(local); &#125; &#125; return uniq.length;&#125;; 字符串操作一、slice、substring 、substr——截取字符串,但不修改字符串本身的值1.单个参数三种方法都一样，从开始位置进行截取 2.两个参数slice 、substring 截取开始和结束的 index（但不截取该位置字符） 而 substr 是开始索引 index 和 长度。 3. 参数出现负数当以上三种若参数中出现负数时，情况各不相同 slice 会将传入负值与字符串长度相加， substr 会将负数的第一个参数加上字符串长度，第二个参数若为负数则转换为 0 ， substring 会将所有负值参数转换 0 123456var value = "hello world" //共11位alert(value.slice(-3)); // rldalert(value.substring(-3)) // hello world 相当于 value.substring(0)alert(value.substr(-3)) // rldalert(value,slice(3,-4)) // lo walert(value.substring(3,-4)) //hel 相当于 value.substring(3,0); 注意：只有 substring 方法会将较小的数作为开始位置 1value.substring(3,1) 相当于 value.substring(1,3) 二、join() 和 split(),一个为连接数组，一个为拆分数组，括号内填写连接或者拆分的字符串。三、concat 拼接一个或多个字符串1234var value = "hello ";var result = value.concat("world","!");alert(result); //"hello world!"alert(value); //"hello" 数组操作一、拆分——slice 和 splice前者 slice 需要开始和结束索引，并返回一个子数组（但不改变原数组） splice 则需要开始索引和长度（会改变原数组），并返回一个子数组 slice 为浅拷贝， ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 背景图设置]]></title>
    <url>%2F2018%2F12%2F05%2Fcss%2FCSS3%20%E8%83%8C%E6%99%AF%E5%9B%BE%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[CSS3 背景图设置一、设置背景图background-image: url(&#39;/static/img/background.jpg&#39;); 二、设置背景图大小 三、设置其他属性集合1234background-repeat: repeat || repeat-x || repeat-y || no-repeat background-origin: content-box || padding-box || border-box;//规定背景图片的定位区域background-image: url(1.jpg),url(2.jpg);// 允许使用多个背景图片]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器缓存知识记录]]></title>
    <url>%2F2018%2F01%2F08%2Fbrowser%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[浏览器缓存知识记录一、浏览器缓存基本知识浏览器的缓存机制有两种，一种为 强缓存， 另一种是 协商缓存 浏览器在请求资源之前会在 http 的 headers 中判断是否命中强缓存，如果命中浏览器就直接在自己的缓存中加载资源，不会发送请求到服务器。 如果强缓存没命中，浏览器会发送一个请求到服务器，服务器会根据状态码 二、强缓存原理 当浏览器对某个资源命中强缓存的时候，返回的状态码为 200 ，在chrome 的开发者工具的 network 里面 size 会显示 from cache(新版本的 chrome 改为 from disk cache/from memory cache) 强缓存主要是通过 expires 、cache-control 进行判断 1. Exipres 是 http1.0 提出的一个表示资源过期时间的header它由服务器返回，描述的是一个终止的绝对时间，如： Expires:Thu, 31 Dec 2037 23:55:55 GMT 其原理是： 1） 第一次请求资源的时候，response 的header 会带有Expires 的headers; 2）浏览器会在接受到这资源后连同所有的 response header一起缓存下来（所以缓存命中的请求返回的header 并不是 来自服务器，而是来自之前的 缓存 header) 3) 浏览器再次请求该资源的时候，会从缓存中寻找是否有这个资源，然后拿出它的 Expires 和当前时间进行比较，如果该时间之前，就能命中缓存，否则不行 4）如果缓存没有命中，浏览器会直接从服务器加载资源，同时该资源的 Expires 在重新加载的时候将会更新 但是有个问题是，如果随意修改下客户端的时间，会印象缓存命中的结果，所以有了 cache-control 2. Cache-Control 是 http1.1 提出的一个新 header以秒为单位, 如 cache-control: max-age=3153600000 流程与上同，只是在判断的时候根据第一次请求的时间和Cache-Control 设定的有效期与当前时间进行比较。 上面两个 header 可以同时启用，也可只启用一个，但是 Cache-Control 的优先级浩宇 Expires 三、协商缓存原理协商缓存是利用 【Last-Modified, If-Modified-Since】（最后一次修改时间） 和 【ETag、If-None-Match】（资源的位移标识——字符串，只要资源变化就会修改） 这两对 Header 进行管理 第一次发送请求是响应body 带有 (Last-Modified / ETag) 浏览器再次发送请求资源时 会在 Header 中加上 If-Modified-Since/If-None-Match 的 header，这个值为上次请求返回的 Last-Modified/ ETag 。 服务器通过上述值 If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，相同则说明没有更改，则返回 304 Not Modified，并且在 response header 中不会再添加 Last-Modified 的 header ，因为既然资源没有变化，那么 Last-Modified 就不会改版；如果不相同（有变化），则返回正常资源内容。 当服务器接收到值 If-None-Match和然后再根据资源生成的一个新的 ETag 比较，如果两个值相同则说明两个资源没有变化， 如果没有变化则返回 304 Not Modified ，并且不返回资源，但和 If-Modified-Since不一样的是，ETag 重新生成过，所有response header 还是会把这个 ETag 返回，即使与原来相同。 浏览器如果收到304 响应，就会子啊缓存中加载资源 四、浏览器行为对缓存的影响浏览器以下的行为将会影响缓存： 1) 当 crtl + f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存 2) 当 f5 刷新页面的时候，跳过强缓存，但会检查协商缓存 引用： https://www.cnblogs.com/lyzg/p/5125934.html https://www.cnblogs.com/chenqf/p/6386163.html]]></content>
      <categories>
        <category>browser</category>
      </categories>
      <tags>
        <tag>browser</tag>
      </tags>
  </entry>
</search>
