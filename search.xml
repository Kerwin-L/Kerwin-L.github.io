<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F06%2F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94FormData%20%E5%AF%B9%E8%B1%A1%E4%B8%8E%20Fetch%20%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[文件传输记录——FormData 对象与 Fetch 使用技术介绍Fetch API 是一个 H5 的 API，被认为是未来取代 XHR 技术的新标准 Fetch 是基于 promise 语法结构 快速了解支持原生的 promsie 使用，并且也可以配合 ES2016 的 async / await 语法进行，更加优雅 1234567891011121314151617181920212223//获取 json 资源fetch('some.json') .then(function(response)&#123; return response.json(); &#125;) .then(function(data)&#123; console.log('data',data); &#125;) .catch(function(error)&#123; console.log('Fetch Error: ',error); &#125;)// 采用 await/ async 方式async functioin()&#123; try&#123; const response = await fetch('somm.json')； const data = response.json(); console.log('data',data); &#125; catch (error) &#123; console.log('Fetch Error',error) &#125; &#125; 由上面例子可以看出，fetch api 可以通过很优雅的 异步方式与服务端进行通信 Fetch 用法121. Promise Fetch(String url,[,Object options])2. Promise fetch(Request req,[,Object options]) 第一个参数为 url 地址，第二个参数为配置信息，可选 第一个参数为 Request 对象，第二个参数为配置信息，可选 Formdata 技术介绍MDN 的解释如下: FormData 对象将数据编译成键值对，以便于 XMLHttpRequest 来发送信息。其主要用于发送发送表单数据，但亦可用于发送带键数据。 其实主要是用于对文件的传输，配合着 File 对象进行传输（File 对象是特殊类型的 Blob ） 详情请见这里：https://juejin.im/post/5b32fb5cf265da598223df9e 在这个过程容易发生的问题是 https://aotu.io/notes/2017/04/10/fetch-API/index.html]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F06%2F%E5%A8%B1%E4%B9%90%E8%87%B3%E6%AD%BB%2F</url>
    <content type="text"><![CDATA[娱乐至死这本是前言就引出了两位小说家对未来的预测，先来欣赏一下前言的最后一段 奥威尔害怕的是那些强行禁书的人，赫胥黎担心的是失去任何禁书的理由，因为再也没有人愿意读书了；奥威尔害怕的是那些剥夺我们信息的人，赫胥黎担心的是人们在汪洋如海的信息中日益变得被动和自私；奥威和害怕的是真理被隐瞒，赫胥黎担心的是真理被淹没在无聊琐碎的世事中；奥威尔害怕的是我们的文化称为受制文化，赫胥黎担心的是我们的文化成为充满感官刺激、欲望和无规则游戏的庸俗文化。 简而言之，奥威尔担心我们憎恨的东西会毁掉我们，而赫胥黎担心的是，我们将毁灭于我们热爱的东西。 两个人的所担心的并不冲突，而后者更是无形的可怕。 本书初版撰写于 1985 年，虽然现在时隔 34 年，但是将整本书读完之际，你将会感受到作者强烈的对现实的预言。 全文主要分为两大部分： 媒介从文字到图像，通过前后现在的对比，突出现在人思考能力的转变 针对当时具体的行业的现象进行挖掘分析，不断的往底层去剖析。 对当时娱乐行业中心只是为了抓人眼球的批判 从一个”好······现在” 这种现象 金句记录：（不分先后） 第十章 ： 也许人们对于教育最大的错误认识是，一个人学会的只有他当时正在学习的东西。其实，伴随学习的过程形成持久的态度······也许比拼写课或地理历史课更为重要······因为持久的态度才是在未来发挥重要作用的东西。————约翰·杜威 第三章： 在印刷术统治下的文化中，公众话语往往是事实和观点明确而有序的组合，大众通常都有能力进行这样的话语活动。在这样的文化，如果作者撒谎、自相矛盾、无法证明自己的观点或者滥用逻辑，他就会犯错误。这样的文化中，如果读者没有判断力，他也会犯错误；如果他对一切漠不关心，情况则会更糟糕。 第七章 当新闻被包装成一种娱乐形式时，他就不可避免地起到了蒙蔽作用。我前面说过，电视新闻节目提供给观众的是娱乐而不是信息，这种情况的严重性不仅在于我们被剥夺了真实的信息，还在于我们正在逐渐失去判断什么是信息的能力。无知是可以补救的，但是如果我们把无知当成知识，我们该怎么做呢？]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F06%2F%E5%B0%8F%E6%84%9F%E6%82%9F%2F</url>
    <content type="text"><![CDATA[在面对一些困难的时候，烦躁就会不断升级，会蒙蔽你能想到的一些方式，所以当面对事情的时候，不是死磕，而需要进行转弯。这是为了让你从不同的角度审视这件事情，而不是一种逃避。 现在面临就业的我，焦虑，烦恼，对未来的迷茫。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F17%2FMongoose%20%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Mongoose 学习笔记引用至 mongoose https://cnodejs.org/topic/504b4924e2b84515770103dd]]></content>
  </entry>
  <entry>
    <title><![CDATA[读后感]]></title>
    <url>%2F2019%2F01%2F29%2F%E5%A8%B1%E4%B9%90%E8%87%B3%E6%AD%BB-%E8%AF%BB%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[这本是前言就引出了两位小说家对未来的预测，先来欣赏一下前言的最后一段 奥威尔害怕的是那些强行禁书的人，赫胥黎担心的是失去任何禁书的理由，因为再也没有人愿意读书了；奥威尔害怕的是那些剥夺我们信息的人，赫胥黎担心的是人们在汪洋如海的信息中日益变得被动和自私；奥威和害怕的是真理被隐瞒，赫胥黎担心的是真理被淹没在无聊琐碎的世事中；奥威尔害怕的是我们的文化称为受制文化，赫胥黎担心的是我们的文化成为充满感官刺激、欲望和无规则游戏的庸俗文化。 简而言之，奥威尔担心我们憎恨的东西会毁掉我们，而赫胥黎担心的是，我们将毁灭于我们热爱的东西。 两个人的所担心的并不冲突，而后者更是无形的可怕。 本书初版撰写于 1985 年，虽然现在时隔 34 年，但是将整本书读完之际，你将会感受到作者强烈的对现实的预言。 全文主要分为两大部分： 媒介从文字到图像，通过前后现在的对比，突出现在人思考能力的转变 针对当时具体的行业的现象进行挖掘分析，不断的往底层去剖析。 对当时娱乐行业中心只是为了抓人眼球的批判 从一个”好······现在” 这种现象 金句记录：（不分先后） 第十章 ： 也许人们对于教育最大的错误认识是，一个人学会的只有他当时正在学习的东西。其实，伴随学习的过程形成持久的态度······也许比拼写课或地理历史课更为重要······因为持久的态度才是在未来发挥重要作用的东西。————约翰·杜威 第三章： 在印刷术统治下的文化中，公众话语往往是事实和观点明确而有序的组合，大众通常都有能力进行这样的话语活动。在这样的文化，如果作者撒谎、自相矛盾、无法证明自己的观点或者滥用逻辑，他就会犯错误。这样的文化中，如果读者没有判断力，他也会犯错误；如果他对一切漠不关心，情况则会更糟糕。 第七章 当新闻被包装成一种娱乐形式时，他就不可避免地起到了蒙蔽作用。我前面说过，电视新闻节目提供给观众的是娱乐而不是信息，这种情况的严重性不仅在于我们被剥夺了真实的信息，还在于我们正在逐渐失去判断什么是信息的能力。无知是可以补救的，但是如果我们把无知当成知识，我们该怎么做呢？]]></content>
  </entry>
  <entry>
    <title><![CDATA[不是不到，而是时候未到]]></title>
    <url>%2F2019%2F01%2F25%2F%E4%B8%8D%E6%98%AF%E4%B8%8D%E5%88%B0%EF%BC%8C%E8%80%8C%E6%98%AF%E6%97%B6%E5%80%99%E6%9C%AA%E5%88%B0%2F</url>
    <content type="text"><![CDATA[”学习是有滞后性的“，”任何东西从后往前看，都可以找到联系，从前往后看看不到学习的意义“，“不是不到，而是时候未到” 每每在坚持的时候，看到的都是一片迷茫，坚持下去就会好的。 坚持一天，没问题，两天，没问题吧，三天，可能就犹豫了。然后继续打鸡血，继续努力，继续消磨，周而复始。 宛如肩扛着承重的行囊，奋力的往前面踏上几步，然后因受不了重量而倒下，躺了躺，拍拍身上的尘，继续往前踏上几步，继续如此。 当望望手上的茧，便想：“这应该是每个人都要经历的吧”，而正当想到如此，才能继续坚持往前行。这可能就是我这类人的生活吧。 但是身上那种盼望美好还是没有消失，模模糊糊知道这对你好，坚持就罢了。 熬 熬 熬 但是谁又知道要熬过久呢？一个月？半年？一年？不知道。 但这不就正是生活吗？没有这种苦行僧的生活哪有最后得到的那种甜蜜？ 不过当你坚持过来的时候，得到你想要的，真实的情况你会异常的平静，因为这不就是你花费不知道多少多少时间得到的东西吗？嗯，终于来了。 哈哈哈哈哈 这可能就是写文章吧哈哈哈哈，真的是，画风真实搞笑，就 TM 去坚持就好了，虽然不用玩命的坚持，管他呢，坚持下去才会不一样。 最后就以乔布斯的话结尾吧，也就是开头一句话的后半部分 任何东西从后往前看，都可以找到联系，从前往后看看不到学习的意义。看似无意义，目的性没那么强的事在将来看都有意义的，只要你沉醉其中全心全意去做 ————史蒂夫·乔布斯]]></content>
      <categories>
        <category>认知</category>
      </categories>
      <tags>
        <tag>认知</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小记 inline 中的小坑]]></title>
    <url>%2F2019%2F01%2F23%2F%E5%B0%8F%E8%AE%B0-inline-%E4%B8%AD%E7%9A%84%E5%B0%8F%E5%9D%91%2F</url>
    <content type="text"><![CDATA[在开发项目的时候发现，img 合成的一系列图片之间都有小白条！！ 一、为什么会有小白条？img 是 inline-block 元素，由于基线的缘故，图片下方到buttom 会有一定的距离 二、 解决办法 设置 display: block; 将其父元素容器设置为 font-size: 0 (但 chrome 要另外设置为-webkit-text-size-adjust:none;，因为谷歌设置了默认字体的大小) vertical-align: middle/ top /bottom（仅能消除上下图片的小白条，左右并无效） 三、内联元素和内联块元素之间的小白条 因为他们标签之间有空格/换行，就会有间隔 四、解决办法 移除空格 font-size: 0 父元素设置 font-size: 0 , 若子元素需要展示,另外设置子元素的 font-size，但是 chrome 有默认最小字体 所以需要另外设置 -webkit-text-size-adjust:none;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex 用法记录]]></title>
    <url>%2F2019%2F01%2F15%2Fvuex%E7%94%A8%E6%B3%95%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Vuex 人称：状态管理模式 一、State 组件使用方法 通过 computed 形式 12345678const Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed:&#123; count()&#123; return store.state.count; //store 为 new Vuex.store(&#123;&#125;) 创建的对象 &#125; &#125;&#125; Vuex 通过 store 选项，提供一种机制将状态从根组件注入到每一个子组件（调用 Vue.use(Vuex)）: 12345678910const app = new Vue(&#123; el： '#app', store, components:&#123; counter &#125;, template: ` &lt;div class="app"&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; ` &#125;) 通过在根组件中注册了 store ，所以该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 进行访问，所以 Counter 实例可以更新为 12345678const Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count () &#123; return this.$store.state.count &#125; &#125;&#125; mapState 辅助函数 用于多个变量的注入，减少重复敲代码 1234567891011121314151617import &#123; mapState &#125; from vuexexport default &#123; //.. computed: mapState(&#123; //箭头函数可以使代码更简练 count: state=&gt;state.count, //传入字符串参数 等同于 state=&gt;state.count count2: 'count' //如果使用 this 必须使用常规函数 countNumber(state)&#123; return state.count + this.localCounts &#125; &#125;)&#125; 如果计算属性的名称与 state 中子节点的名称相同，则可以往 mapState() 传入数组 123computed: mapState([ 'count']) 二、 getters可以看做 store 的计算属性 12345678910111213const store = new Vuex.store(&#123; state:&#123; todos:[ &#123;id: 1,name: 'laoluo',done: true&#125;, &#123;id: 2,name: 'xiaoluo',done: false&#125; ] &#125;, getters:&#123; doneTodos: state=&gt;&#123; return state.todos.filter(todo=&gt;todo.done); &#125; &#125;&#125;) 通过属性访问1this.$store.getters.doneTodos; //[&#123;id: 1,name: 'laoluo',done: true&#125;] getters 同样接受其他 getters 当做第二参数 123456getters:&#123; //.. doneTodosCount: (state,getters)=&gt;&#123; return getters.doneTodos.length &#125;&#125; 1this.$store.getters.doneTodosCount // 1 通过方法访问可以通过 getters 返回一个函数，通过给函数传参等到想要的值 123456789getters:&#123; //.. getTodoById: (state)=&gt;(id)=&gt;&#123; return state.todos.find(todo=&gt;todo.id === id); //find() 找到第一个符合条件的值并返回 &#125; &#125;store.getters.getTodoById(1) //[&#123;id: 1,name: 'laoluo',done: true&#125;] 与上同有 mapGetters 属性后续：双向绑定的计算属性 本身如果使用vuex 并不能直接通过 v-model 直接进行绑定，因为本身 vuex 的修改是要经过 mutation 进行监控。 所以可以通过一个双向绑定的计算属性进行设置 12345678910111213&lt;input v-model="message"&gt;//..computed:&#123; message: &#123; get()&#123; return this.$store.state.obj.message &#125;, set(value)&#123; this.$store.commint('updateMessage',value) &#125; &#125;&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[作用域闭包]]></title>
    <url>%2F2019%2F01%2F12%2F%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[作用域闭包闭包（closure）又称为 词法闭包（Lexical Closure) 和 函数闭包（function closures) 闭包这个词是前端开发中必补可少的词，其定义就是，函数 A 内部有一个函数 B， 然后函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。 作用： 延长作用域链、实现数据封闭、实现模块化 最常见看到需要闭包的地方 12345678910111213141516171819202122232425for(var i=0;i&lt;3;i++)&#123; setTimeout(function()&#123; console.log(i); &#125;,1000);&#125;// 6// 6// 6——————————————————————用闭包的方式去实现 (IIFE 立即执行函数)for(var i=0;i&lt;3;i++)&#123; setTimeout((function(j)&#123; console.log(j) &#125;)(i) ,1000);&#125;// 或者这样for(var i=0;i&lt;3;i++)&#123; (function(j)&#123; setTimeout(function()&#123; console.log(j); &#125;,1000); &#125;)(i)&#125; 12345678910111213141516function foo()&#123; var a = [0]; function join(b)&#123; a.push(b); &#125; function get()&#123; return a; &#125; return &#123; join: join, get: get &#125;&#125;var a = foo();a.join(1);a.get(); // [0,1] 只要使用了回调函数，实际上就是在使用闭包!]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 this]]></title>
    <url>%2F2019%2F01%2F11%2F%E5%85%B3%E4%BA%8E-this%2F</url>
    <content type="text"><![CDATA[this 全面解析this 在任何情况下都不属于词法作用域重点： this 是 运行时 进行绑定，不是编译时绑定，其上下文取决于函数调用时的各种条件 123456789101112131415function foo(num)&#123; console.log("foo "+ num ); //记录 foo 的调用次数 this.count ++ ;&#125;foo.count = 0;var i;for(i=0;i&lt;10;i++)&#123; if(i&gt;5)&#123; foo(i); &#125;&#125;//所以最后这个将会输出多少？console.log(foo.count); 答案是： 0 ，有没有感到疑惑呢？？ 原因是函数内部的 this 指向的是全局，而不是函数内的一个属性 123456789function foo()&#123; var a = 2; this.bar();&#125;function bar()&#123; console.log(this.a);&#125;var a = 'hello~'foo(); //hello~ 一、 this 绑定对象——四条规则 由 new 调用 ？ 绑定到新创建的对象 由 call 或者 apply（ bind ）调用？ 绑定到指定的独享—————显示绑定 由上下文对象调用？（ object.fun() ) 绑定到该上下文————隐式绑定 默认： 在严格模式下绑定到 undefined ，否则绑定到全局对象——默认绑定 特别： 数组的 forEach方法，第一个参数为函数，第二个为绑定上下文的对象 默认绑定： 严格模式下，this 会绑定到 undefined ，但在严格模式下调用 foo（）则不影响绑定 1234567891011121314151617function foo()&#123; "use strict"; console.log(this.a);&#125;var a = 2;foo();//TypeError: this is undefined---------------------------------------function foo()&#123; console.log( this.a ); &#125;var a = 2;(function()&#123; "use strict" foo(); //2&#125;)(); 隐式绑定容易出现问题–隐式丢失1234567891011121314151617181920212223242526function foo()&#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;var bar = obj.foo; //函数别名!!!var a = 'Good Job';bar(); // 'Good Job'----------------------------------------更常见的一种方式function foo()&#123; console.log(this.a);&#125;function doFoo(fn)&#123; fn();&#125;var obj = &#123; a: 2, foo: foo&#125;var a = 'Good Job';doFoo(obj.foo);// 'Good Job'//参数传递其实也是隐式赋值 二、 绑定例外若不需要上下文的时候，显示绑定的第一个参数 设置为 null ,或者通过 Object.create(null) 创建一个 DMZ(demilitarized zone 非军事区)不会包含 Object.prototype 的对象 2.1 间接引用12345678function foo()&#123; console.log(this.a);&#125;var a = 2;var o = &#123;a: 3 ,foo: foo&#125;;var p = &#123;a: 4&#125;;o.foo() ; //3(p.foo = o.foo)() //2 赋值表达式（p.foo = o.foo) 的返回值是目标函数的引用，因此调用位置是 foo() 而不是 p.foo() 或者 o.foo()。 所以这里是 默认绑定 三、特殊用法箭头函数——其函数中的指向为外层函数 的this]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的 Javascript]]></title>
    <url>%2F2019%2F01%2F10%2F%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84-Javascript%2F</url>
    <content type="text"><![CDATA[你不知道的 Javascript第一章 作用域是什么（LHS RHS 查询）作用域是一套规则，用与确认在何处（where),以及如何查找变量（标识符）。 如果查找的目的是对变量进行赋值，则会调用 LHS 查询。 如果目的是获取变量的值，则使用 RHS 查询 JavaScript 引擎首先会在代码执行之前对其进行编译，以var a = 2为例： 首先 var a 在其作用域中声明新的变量。这会在代码最开始的阶段，也就是代码执行之前（具体原因是因为变量的提升) 接下来 a =2 会 查询（LHS查询）变量 a 并对其进行赋值操作 LHS 和 RHS 查询都会顺着 作用域链 进行查询 不成功的 RHS 引用会导致抛出 ReferenceError 异常。（引用不存在的变量） 不成功的 LHS 引用会导致自动创建一个全局变量（ a = 2 ; 若a 没有声明则会创建为全局变量)————仅限非严格模式下。 第二部分 之 this 和对象原型—— 第 3 章 对象内置对象：String 、Number 、Boolean、Object 、Function、Array 、Date、RegExp、Error 3.2 类型 Javascript 中二进制前三位为 0 的话会被判定为 Object 类型， null 的二进制表示是全 0，自然前三位也是 0 ，所以执行 typeof 时会返回 “object” 1234var str = "I am a string";console.log(str.length); // 13 console.log(str.charAt(3));//m// 为什么能有该属性是因为引擎自动将字面量转换成 String 对象，所以可以使用其属性 12345678var obj = &#123; a: 2&#125;;obj.a ; // 2 ———— 属性访问obj['a']; //2 ———— 键访问/*两者主要区别是 . 操作符要求属性名满足标识符的命名规范（除了_ $。不能使用特殊字符），而['..'] 语法可以接受任意 UTF-8/Unicode 字符串作为属性名。*/ [‘..’] 该用法中的可以为变量，并且里面的变量都会转换成 字符串的形式 1234567891011121314var obj = &#123; a: 2&#125;;var id = a ;console.log(obj[id]); //2 var obj2 =&#123;&#125; ;obj2[true] = 'foo';obj2[3] = 'bar';obj2[obj2] = 'baz';obj2['true']; // 'foo'obj2['3'] ; // 'bar'obj2["[Object Object]"] // 'baz' 划重点！ ES6 中刚才提到的键访问形式(obj[..]) 中可以进行计算1234567var prefix = 'foo';var obj = &#123; [prefix + "bar"]: "hello", [prefix + "baz"]: "world"&#125;obj["foobar"]; // helloobj["foobaz"]; // world 3.3.4 复制对象深复制： 通过 JSON.parse(JSON.stringify(someObj)) 浅复制：Object.assign(..) ——第一个参数为 目标对象，后面可以跟一个或多个源对象 浅复制关键点： 它会遍历一个或多个源对象中可枚举（enumerable）的自有键( owned key ) 使用 = 操作符赋值 到目标对象中。（由于是 = 操作符赋值，所以源对象属性的一些特性（比如 writable ） 不会复制到目标对象。 3.3.5属性描述符ES5 开始，所有属性都具有属性描述符 writable 可写 、enumerable（可枚举） 和 configurable （可配置） writable：决定事发后可以修改属性的值 ——如果强行更改属性值，非严格模式下会静默失败（silently failed)，严格模式下，会 TypeError configurable: 是否可以通过 Object.defineProperty(..)方法来修改属性描述符——如果设置为false 后，再继续进行修改，则产生一个TypeError错误（不管是否为严格模式）。注意：configurable修改成 false 是一个单项操作，无法撤销！！！ 有一个小小的例外： 即便属性是 configurable: false ，我们还是可以把 writable 的状态由 true 改为 false， 但是无法从 fasle 改为 true enumerable: 是否可枚举 3.3.6 不变性上述的设置都是浅不变性（如： 对 obj.a 设定不可更改，但其obj.a = [1,2,3] ,obj.a.push(4) 仍可执行 所以就有以下的方法 禁止扩展： Object.preventExtensions(yourObject)创建错误同上 密封： 功能： 不能添加新属性 + 不能重新配置或删除现有属性 Object.seal(..)，方法实际是 先 进行 Object.preventExtensions（）,后将所有属性标记为 configurable: false 冻结： 功能： Object.seal() + writable: false object.freeze() 3.3.9 Getter 和 Setter 1234567891011var obj= &#123; get a()&#123; console.log("I am get") return 1 &#125;, set a(newVal)&#123; console.log("I am " + newVal); &#125;&#125;obj.a ; // 打印出 'I am get' ,值为 1 obj.a = 'laoluo'; // 打印出'I am laoluo' 3.3.10 存在性in 操作符时检查属性是否在对象及其 [[Prototype]] 原型链中。 hasOwnProperty(..)是检查属性是否在其对象中 for in只是可以枚举那些可枚举的对象属性（包含原型链上的） propertyIsEnumerable(..) 检查给定属性是否在对象中，并且满足enumerable:: true Object.keys(..) 会返回一个包含所有可枚举属性的数组。（只包含本对象） Object.getOwnPropertyNames(..) 返回所有属性（不管是否可枚举）的数组（只包含本对象） 3.4 遍历数组内置迭代器@@iterator 来对数组进行遍历， ES6 新增方法 for of 用于遍历本身含有迭代器的对象 1234567var arr = [1,2,3];for(var a of arr)&#123; console.log(a);&#125;//1//2//3 for of 循环首先会向被访问对象请求一个迭代器对象，然后通过迭代器对象的 next() 方法来遍历所有返回值。 下面使用数组的迭代器方法来手动遍历数组 1234567var arr = [1,2,3];var it = arr[Symbol.iterator]();it.next();//&#123;value: 1,done: false&#125;it.next();//&#123;value: 2,done: false&#125;it.next();//&#123;value: 3,done: false&#125;it.next();//&#123;done: true&#125; 同样我们也可以任何想遍历的对象定义 @@iterator , 举例来说: 123456789101112131415161718192021222324252627282930313233343536var obj = &#123; a:1, b:2&#125;Object.defineProperty(obj,Symbol.iterator,&#123; enumerable: false, writable: false, configurable: true, value: function()&#123; var o = this; var idx= 0; var ks = Object.keys(o); return &#123; next: function()&#123; return &#123; value: o[ks[idx++]], done: (idx&gt;ks.length) &#125; &#125; &#125; &#125;&#125;)//手动遍历var it = obj[Symbol.iterator]();it.next(); // &#123;value: 1,done:false&#125;it.next(); // &#123;value: 2,done:false&#125;it.next(); // &#123;value: undefined,done:true&#125;//用 for .. of 遍历 obj for(var a of obj)&#123; console.log(a)&#125;// 1// 2 同样也可以用对象字面量的方式定义 [Symbol.iterator] 第三部分——第六章 行为委托重要的概念————原型链:（本质就是对象的关联） 一系列对象的链接成为原型链，（如果在第一个对象没有找到需要的属性或方法，引擎会在 [[ protoType ]] 关联的对象上进行查找，同理，如果没找到会继续在其 [[ protoType ]] 中继续查找]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端路由]]></title>
    <url>%2F2019%2F01%2F08%2Fvue%2FVue-router-%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、为什么可以实现前端路由1. hash 模式因为改变hash 值并不会导致页面的刷新，通过监听 window.onhashname 实现页面内容的切换。 2. history 模式html5 标准发布后，通过两个api pushState 、 replaceState，改变url 但不发送请求 用法： 12345678910pushState(Object,title,url)//往历史记录栈中添加记录//Object 主要用于在 popstate 时间中作为参数被获取//url 新历史记录的地址，可为页面地址也可为一个锚点值，新url 必须与当前url 处于同一个域中，否则抛出异常window.history.pushState(&#123;laoluo:'1'&#125;,'laoluo1',"/page1");//该 url 将会从原来的变成 page1window.onpopchange = function(event)&#123; console.log(event.state) //监听页面的前进后退按钮、调用 back()、forward()、go() &#125; 通过 window.onpopstate = function(event){ }监听 前进后退 二、vue 的路由是怎么样的呢？https://zhuanlan.zhihu.com/p/37730038]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 水平垂直居中小集合]]></title>
    <url>%2F2019%2F01%2F06%2Fcss%2FCSS-%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B0%8F%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[平常前端开发的时候经常遇到这样的问题，时不时就会忘记，今天就想一次性把所有 CSS居中 的方法进行总结，当做自己的备忘录 一、水平居中概括： 内联元素 text-align：center(可继承，块级元素中的行内元素居中 ) 块级元素 margin: 0px auto; 多块级元素，将块级元素设置为 inline-block,再通过 text-align flex 布局 justify-content: center 二、垂直居中概括： 单行元素：height 和 line-height 设置一样的高度 table 布局，父元素设置 display: table ，子元素设置 display: table-cell; vertical-align: center flex 布局 align-center:center CSS3 transform 属性，结合绝对位置，实现垂直居中，部分浏览器会有兼容性问题12345678.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; transform: translateY(-50%);&#125; 三、水平+垂直 布局 flex 双重属性设置居中 table + 设置宽度+ margin 来完成（兼容性有较好的的保证） 未知宽高元素，通过 transform + absolute 123456789.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; 固定宽高——通过设置 absolute 和 margin 反向设置进行 grid 布局（不清楚后期补） 以下是上方部分的详细例子 二、垂直居中1. 单行内联元素垂直居中1234567891011121314&lt;style&gt; .main&#123; height: 200px; background-color: #fcc; overflow: hidden; line-height: 200px; font-size: 40px; &#125;&lt;/style&gt;&lt;template&gt; &lt;div class=&quot;main&quot;&gt; 我是一行 &lt;/div&gt;&lt;/template&gt; 通过 height line-height 配合进行垂直居中 line-height 属性设置行间的距离（不允许为负值） 这个距离是两行之间基线的举例，看下图会很清楚 定义height 的五种方式： 1.line-height可以被定义为：body{line-height:normal;} 2.line-height可以被定义为：body{line-height:inherit;} 3.line-height可以使用一个百分比的值body{line-height:120%;} 4.line-height可以被定义为一个长度值(px,em等) body{line-height:25px;} 5.line-height也可以被定义为纯数字， body{line-height:1.2}—————会通过font-size 自动进行调节 更详细的例子在这里查看 深入了解css的行高Line Height属性 2.多行垂直居中1234567891011121314151617181920&lt;style&gt; .table&#123; display: table; background-color: #4cd1d4; height: 150px; &#125; .cell&#123; display: table-cell; vertical-align: middle; &#125;&lt;/style&gt;&lt;template&gt; &lt;div class=&quot;table&quot;&gt; &lt;div class=&quot;cell&quot;&gt; 我是一行 &lt;br&gt; 我是二行 &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 3. Flex 布局通过设置 flex 布局的交叉轴方向即可 align-items: center12345678910111213&lt;style&gt; .flexStyle&#123; display: flex; align-items: center; height: 100px; background-color: gray; &#125;&lt;/style&gt;&lt;template&gt; &lt;div class=&quot;flexStyle&quot;&gt; flex 布局 &lt;/div&gt;&lt;/template&gt; 三、水平垂直居中###1. 未知宽高元素水平垂直居中利用 2D 变换123456789.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; 利用 flex 布局设置 主轴方向 justify-content 和 交叉轴方向 align-center （也就是纵轴）为 center 就可以达到居中 table布局结合开始 table 垂直居中，外层设置 display:table，内层设置 display: table-cell;vertical: center，最后在通过水平垂直的方法完成 引用参考 CSS line-height概念与举例 深入了解css的行高Line Height属性 这15种CSS居中的方式，你都用过哪几种？]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[习惯的力量——音频记录+感想]]></title>
    <url>%2F2019%2F01%2F05%2F%E8%AE%A4%E7%9F%A5%2F%E4%B9%A0%E6%83%AF%E7%9A%84%E5%8A%9B%E9%87%8F%2F</url>
    <content type="text"><![CDATA[一、习惯是怎么运作 需要一个暗示 是要有一个惯常行为 得到奖赏 二、 如何养成新习惯秘诀：找到一个合适的暗示，加一个习惯养成的奖赏，培养对这种奖赏的渴望 比如： 完美身材，想象当你走在街上，别人对你身材投来的羡慕目光时，你就会对好身材产生渴求感，这种感觉会让你更想去健身，从而养成习惯。（其实也就是一个反馈） 自我理解： 习惯是简化人思考的一种方式，减少人的消耗。 养成一个习惯需要一个长期的反馈机制，也就是上文所说奖赏的渴望]]></content>
      <categories>
        <category>Learning_Method</category>
      </categories>
      <tags>
        <tag>Learing_Method</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[setTimout用法]]></title>
    <url>%2F2018%2F12%2F15%2Fjavascript%2FsetTimout%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[记录常见容易入坑的 JavaScript 用法 1.setTimeout / setInterval 中的函数 this 指向 window下面这个例子可以看出，setInterval/setTimout 中的传入函数中的 this 会指向 window 对象 1234567891011var a = 1;function time()&#123; this.a = 2 ; this.getA = function()&#123; setInterval(function()&#123; console.log(this.a); &#125;,1000); &#125;&#125;var t = new time();t.getA() // 不断的打印出： 1 问题解析：setTimeout / setInterval 中的函数运行环境并不是当前执行环境，导致 this 指向 window 对象，详细可以看 MDN setTimeout 解决方法： 在当前对象中设定一个新变量 that 指向原来的 this 123456789101112var a = 1;function time()&#123; this.a = 2 ; var that = this; this.getA = function()&#123; setInterval(function()&#123; console.log(that.a); &#125;,1000); &#125;&#125;var t = new time();t.getA() // 不断的打印出： 2 通过 bind 方式设置作用域 1234567891011var a = 1;function time()&#123; this.a = 2 ; this.getA = function()&#123; setInterval(function()&#123; console.log(this.a); &#125;.bind(this),1000); &#125;&#125;var t = new time();t.getA() // 不断的打印出： 2 通过箭头函数，该方法 this 总是指向外层调用者的 this 1234567891011var a = 1;function time()&#123; this.a = 2 ; this.getA = function()&#123; setInterval(()=&gt;&#123; console.log(this.a); &#125;,1000); &#125;&#125;var t = new time();t.getA() // 不断的打印出： 2]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3 动画]]></title>
    <url>%2F2018%2F12%2F12%2Fcss%2Fcss3-%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[今天终于发现这个神奇的操作了，transition ，今天深入了解了下，只要在当前的样式中设置了 transition，未来如果对当前 dom 的样式进行更改，则会通过 transition 进行样式的过渡，非常的顺滑，下面就对方法进行记录 先从样式边变形开始，这可以增加样式的多样性 一、CSS3 变形transform 属性的的基本语法如下 transform: none | &lt;transform-function&gt; 2D transform 常用的 transform-function 的功能： 函数 功能描述 translate() 移动元素，根据X轴和Y轴坐标重新定位元素位置，扩展函数有 translateX() , translateY() scale() 缩小或放大元素 rotate() 2d 旋转元素 skew() 元素倾斜，在此基础上扩展 skewX() , skewY() matrix() 定义矩阵变形 3D transform 常用的 transform-function 的功能 函数 功能描述 translate3d() 指定一个3D变形移动位移量 translateZ() 在 Z 轴上的位移 scale3d(sx,sy,sz) 放大、缩小 scaleZ(s) rotate3d(x,y,z,a) x,y,z 分别为绕各轴的矢量值（0-1的数值），a为角度值__3d旋转 rotateX()、rotateY()、rotateZ() perspective() 透视投影，值越大角度出现的越远，值越小，角度出现的越近,transform: perspective(300px) matrix3d() 二、CSS3 过渡 —— transitiontransition: &lt;property&gt; &lt;duration&gt; &lt;animation type&gt; &lt;delay&gt; 相当于 transition: &lt;过渡属性&gt; &lt;过渡所需时间&gt; &lt;过渡动画函数&gt; &lt;过渡延迟时间&gt; 1、过渡属性指定某一种 css 样式进行过渡 例： transition-property: all || none || width || background-color ….基本的css 样式都能 3、过渡动画函数该属性指定某种指定的过渡函数： 值 描述 linear 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。 ease 规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。 ease-in 规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)） ease-out 规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。 ease-in-out 规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。 cubic-bezier(n,n,n,n) cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。 三、animationanimation: &lt;animtion-name&gt; &lt;animation-duration&gt; &lt;animation-timing-function&gt;&lt;animation-delay&gt;&lt;animation-iteration-count&gt;&lt;animation-direction&gt;&lt;animition-fill-code&gt;&lt;animation-play-state 在每个动画定义中，顺序很重要：解析为&lt;time&gt;的第一个值会被分配给 animation-duration，第二个分配给 animation-delay initial value：（初始值） 变量名 值(第一个值都为初始值) animation-name none animation-duration 0s animation-timing-function ease animation-delay 0s animaiton-iteration-count(运行次数) 1 次数（可为小数）/ infinite animaiton-direction normal/reverse/alternate/alernate-reverse animation-fill-mode none / forwards / backwords / both animation-play-state running / paused 特别解释： animation-fill-mode首先，动画可以划分为 初始状态 等待期 动画执行期 完成期 四个阶段 forwards 表示 等待期保持原始样式，完成期间保持最后一帧样式 backwards 表示等待期保持第一帧样式，完成期跳转到初始样式 none 默认值，等待期和完成期都是 初始样式 both: 表示等待期 为第一帧样式， 完成期间保持最后一帧样式 这个回答的第一条的图很形象的描述 animation-play-state123456789101112131415161718192021222324252627/*保持动画的运行,当 hover 时运行，离开时暂停下面是一个长条形在 hover 时转动 ，离开时自动暂停，hover 时从暂停位置继续开始*/div &#123; animation: spin 1s linear infinite; animation-play-state: paused;&#125;div:hover &#123; animation-play-state: running;&#125;@keyframes spin&#123; to&#123; transform: rotate(360deg); &#125;&#125;.color&#123; width: 200px; height: 50px; background-color: orange;&#125;---- 下面为 HTML ----&lt;div class="color"&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长回文序列]]></title>
    <url>%2F2018%2F12%2F10%2Fleetcode%2F%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: 123Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. Example 2: 12Input: &quot;cbbd&quot;Output: &quot;bb&quot; 回文需要分为奇数和偶数列 然后分为两层循环，一层为字符循环，一层为长度循环 主要关键点为边界条件，奇数列循环时的需要考虑前后边界 以及要考虑 偶数列的话，要排除特殊情况（ccc 的回文序列为 cc ，在欧数列中需要进行设置） 12345678910111213141516171819202122232425262728293031323334353637/** * @param &#123;string&#125; s * @return &#123;string&#125; */var longestPalindrome = function(s) &#123; var arr = s.split(''); var start = 0, end = 0; for(let i = 0; i&lt; arr.length; i++)&#123; for(let j = 1; j &lt;= i &amp;&amp; i + j &lt; arr.length; j++)&#123; if(arr[i-j] == arr[i+j])&#123; if( 2 * j &gt; end - start)&#123; start = i - j; end = i + j; &#125; else continue; &#125; else break; &#125; if(i &lt; arr.length - 1 &amp;&amp; arr[i] == arr [i+1])&#123; if(end - start &lt; 2)&#123; start = i; end = i + 1; &#125; for(let j = 1; j &lt;= i &amp;&amp; i + j +1 &lt; arr.length; j++)&#123; if(arr[i-j] == arr[i +j +1])&#123; if(2 * j + 2 &gt; end - start +1)&#123; start = i - j; end = i + j + 1; &#125; else continue; &#125; else break; &#125; &#125; &#125; return s.substring(start,end + 1);&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 滚动操作]]></title>
    <url>%2F2018%2F12%2F10%2Fjavascript%2Fjavascript-%E6%BB%9A%E5%8A%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[今天在使用 vonic 的时候，因为适配的组件的 position: absolute 然后发现 window.scrollTop 这东西， 下面就想深入了解，然后发现，所有的dom 元素都有 scrollTop scrollHeight clientHeight 等属性，所以可以直接通过 scrollTo() 方法直接设置 scrollTop JS监听滚动监听12345678910111213141516window.addEventListener('scroll',fun()) //添加滚动监听时间也可以对一个 dom 元素进行监听&lt;style&gt;.app&#123; height: 100px; overflow: scroll;&#125;&lt;/style&gt;&lt;div class="app" id='scroll'&gt; &lt;table&gt; &lt;/table&gt;&lt;/div&gt;document.getElementById.scrollTo(x,y) //可以直接设定里面元素scroll中的位置 ​]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3. longest Substring Without Repeating Characters--Medium]]></title>
    <url>%2F2018%2F12%2F07%2Fleetcode%2F3-longest-Substring-Without-Repeating-Characters-Medium%2F</url>
    <content type="text"><![CDATA[3. longest Substring Without Repeating Characters–MediumGiven a string, find the length of the longest substring without repeating characters. Example 1: 123Input: &quot;abcabcbb&quot;Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2: 123Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1. Example 3: 1234Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. 另一个大佬的写法，看看，其实这道题并不难，你的出发点有错误而已，不要自以为的认为某种方法慢，对其进行分析 方式一：在主要通过 flag 判断当前开始位置，通过 indexOf(searchIndex,fromIndex) 从flag 位置开始寻找是否有相同的字符，若有则改变 flag ，并判断是否修改最大值。 12345678910111213141516/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123; if (!s.length) return 0; var max = 1, flag = 0 for(var i = 0; i &lt; s.length; i++) &#123; var index = s.indexOf(s[i], flag) if (index !== -1 &amp;&amp; index &lt; i) flag = index + 1; //也可写为 if(index&lt;i),因为index 一定存在，并且 max = Math.max(max, i - flag + 1) &#125; return max&#125;; 方式二：通过一个 str存储字符串，cache 数组存储数组位置 当字符在 cache 中不存在时，则往 str 加入该字符和 cache 中加入以其字符为key、坐标为值的该字符对象。 当字符存在时： 先判断与最大值的长度比较 获取当前字符的位置 对 str 字符进行截取（从 index+1 开始) 12345678910111213141516171819202122232425262728293031323334/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123; var max = 0; var str = ''; var i = 0; var cache = []; while (i &lt; s.length) &#123; if (cache[s[i]]) &#123; // Found a repeating character. if (str.length &gt; max) &#123; max = str.length; &#125; var start = str.indexOf(s[i]); str = str.substring(start + 1); &#125; if (i &lt; s.length) &#123; str += s[i]; cache[s[i]] = i + 1; i++; &#125; &#125; if (str.length &gt; max) &#123; max = str.length; &#125; return max;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[速读笔记]]></title>
    <url>%2F2018%2F12%2F07%2F%E8%AE%A4%E7%9F%A5%2F%E9%80%9F%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[速读学习阅读关键 通过标题理解主要内容 缩短视觉定焦时间 加大视觉幅度（视幅） 阅读技能： 防止回调阅读 通过视读进行阅读 六个大坑 速读不是阅读完就会的，需要可以练习，至少学习 6 周才能掌握 速读不是省略的阅读，而是加快速度的逐句阅读 速读并不是聪明人的专利，而是人人都能掌握基础技能 速读不是稀释理解能力的阅读，而是脑力全开的阅读方式 速读不是一直保持一种速读，而是一种变速阅读方式 练习速读是一种科学的速读套路 自己理解： 需要可以训练 每个人都能掌握 尽可能的利用大脑 一、技能篇 001 谨记四要素16个字： 刻意拉伸、专项训练、及时反馈、全身关注 为什么牛逼的人能坚持，因为都是有反馈呀！ 所以训练的时候需要进行记录，让自己看得到进步，得到正反馈。 二、技能篇002 眼球运动训练锻炼眼部肌肉 手指引导法（因为人的眼睛是不会走直线） 通过 三、技能篇003 基础技能模块二： 视觉定焦训练 符号训练法 有节奏的默念法 手指刷页法————推荐 图解电影翻页法 四、技能篇004 基础技能模块三： 视觉幅度训练1. 语义单元法——重点笨鸟真的不一定先飞，因为可能你花费的时间的效率可能远远不足人家。 当你的大脑看了半分钟的文字后还没能了解当前文章的大意，大脑就是懈怠（人类的大脑是世界上最强大的超级计算机，会进行罢工 2. 立体图法3. 字母树法]]></content>
      <categories>
        <category>Learning_Method</category>
      </categories>
      <tags>
        <tag>Learing_Method</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2. Add Two Numbers——medium]]></title>
    <url>%2F2018%2F12%2F05%2Fleetcode%2F2.%20Add%20Two%20Numbers%E2%80%94%E2%80%94medium%2F</url>
    <content type="text"><![CDATA[2. Add Two Numbers——medium You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: 123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 这道题并不难： 其实就是通过进位进行设置而已。 把握好一些边界条件。当两个链表长度不等怎么办，最后一位含有进位如何 三个步骤: 判断节点 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var addTwoNumbers = function(l1, l2) &#123; var h1 = l1; var h2 = l2; var l3 = new ListNode(0); var current = l3; var carry = 0; while (h1 !== null || h2 !== null) &#123; var x = h1 !== null ? h1.val : 0; var y = h2 !== null ? h2.val : 0; var sum = x + y + carry; carry = Math.floor(sum/10); current.next = new ListNode(sum % 10); current = current.next; if(h1 !== null) &#123;h1 = h1.next&#125;; if(h2 !== null) &#123;h2 = h2.next&#125;; &#125; if (carry &gt; 0) &#123; current.next = new ListNode(carry); &#125; return l3.next;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[26. Remove Duplicates from Sorted Array]]></title>
    <url>%2F2018%2F12%2F05%2Fleetcode%2F26.%20Remove%20Duplicates%20from%20Sorted%20Array%2F</url>
    <content type="text"><![CDATA[26. Remove Duplicates from Sorted ArrayGiven a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: 12345Given nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.It doesn&apos;t matter what you leave beyond the returned length. Example 2: 12345Given nums = [0,0,1,1,1,2,2,3,3,4],Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn&apos;t matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: 12345678// nums is passed in by reference. (i.e., without making a copy)int len = removeDuplicates(nums);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解题思路： 通过两个变量来控制整个的替换， 1234567891011121314151617181920212223242526/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var removeDuplicates = function(nums) &#123; // if(nums == null || nums.length == 0) return []; // var answer = nums.reduce(function(prev,cur)&#123; // if(prev.indexOf(cur)==-1)&#123; // prev.push(cur); // console.log(prev); // &#125; // return prev; // &#125;,[]) // console.log(answer instanceof Array,nums); // return answer; var a = 0 ; for(var i=1;i&lt;nums.length;i++)&#123; if(nums[a]!= nums[i])&#123; a++; nums[a] = nums[i]; &#125; &#125; nums.splice(a+1,nums.length-a+1); return i;&#125;; 其他人解法 12345678910111213141516171819202122javascript/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */function removeD(sortedArray) &#123; if (sortedArray.length == 0) &#123; return 0 &#125; let i = 1 let j = 1 while(j &lt; sortedArray.length) &#123; if (sortedArray[j] != sortedArray[j-1]) &#123; sortedArray[i] = sortedArray[j] i++ &#125; j++ &#125; return i&#125; 数组操作一、splice 操作原文链接： http://caibaojian.com/js-splice-element.html 删除的数组的某一项splice(index,len,[item]) 注释：该方法会改变原始数组。 splice有3个参数，它也可以用来替换/删除/添加数组内某一个或者几个值 index:数组开始下标 len: 替换/删除的长度 item:替换的值，删除操作的话 item为空 来源： 前端开发博客 二、 Array.reduce()数组 reduce 用法 详解，后期记录 主要是设定初始值的时候格式 array.reduce(function(prev,cru,index,array){ },initialValue) initialValue 可以设置初始值 三、sort() 方法1.sort() 不带参数sort()方法对数组的元素做原地的排序，并返回这个数组。 它是按升序排列数组项。sort()方法会调用每个数组项的 toString() 转型方法，然后按 UNICODE 进行比较，然后根据这个进行排序 来一个简单的例子： 12var a = ['laoluo','kerwin','brady'];console.log(a.sort()); //数组顺序将变为 brady kerwin laoluo 12var 这num = [1,2,8,12,36];a.sort() // 数组顺序改成 1 12 2 36 8 通过charCodeAt()来验证一下 123"laoluo".charCodeAt() // 108"kerwin".charCodeAt() // 107"brady".charCodeAt() // 98 2. sort()中带参数——自己定义排序的函数可以在参数中定义一个比较函数 12345678910111213141516171819202122function compareFun(a,b)&#123; if(a&lt;b)&#123; return -1; // a 排在 b 的前面 &#125;else if(a&gt;b)&#123; return 1; // a 排在 b 后面 &#125;else&#123; return 0; // a和b的位置保持不变 &#125;&#125;//改良版function compareNew(a,b)&#123; return a&lt;b?-1:a&gt;b?1:0;&#125;//新版本升序function ascSort(a,b)&#123; return a - b;&#125;//新版本降序function desSort(a,b)&#123; return b-a;&#125; 通过以下的方式可以对数组进行正确的进行升序排序 12var c = [7,3,5,9,10,4];c.sort(compareFun); // c 数组将改变为 3,4,5,7,9,10 3. 数组随机排序123function randomSort(a,b)&#123; return Math.random() - 0.5;&#125; 更多的方法请参照 https://www.w3cplus.com/javascript/array-part-4.html]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript 循环集合]]></title>
    <url>%2F2018%2F12%2F05%2Fjavascript%2Fjavascript%20%E5%BE%AA%E7%8E%AF%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Javascript 循环集合在使用数组的时候经常用到循环，为了避免用最为简单的循环方法，现在整理下各种新型循环的方法 一、foreach()12345var arr = [1,2,3,'lala'];arr.forEach(function(value)&#123; console.log(value);&#125;)//输出 1 2 3 lala 小缺点： 不能使用 break 语句进行终端，也不能用 return 返回到外层函数 二、for in12345678910var arr = [1,2,3,'lala'];arr.__proto__.name = 'laoluo'; //给 arr 的原型赋予属性namefor(let i in arr)&#123; console.log(i,arr[i]);&#125;// 0 1// 1 2// 2 3// 3 lala// name laoluo 上述代码中，赋给 i 的值并不是数字，而是字符串 ”0“、”1“、”2”、“3” ，此时很可能无意中对其进行字符串操作。例如 “2” + 1 = “21”，会对编码造成极大的不便 for-in 循环体除了遍历数组元素外，还会遍历自定义元素，如果数组中存在可枚举的属性 arr.name ,循环会将额外循环一次，遍历到名’name’的索引。就连数组的原型链上的属性也能被访问到 最令人震惊的是，这段代码可能按随机顺序遍历数组元素！！ 所以，for-in 是为普通对象进行设计的，可以遍历到对象的字符串类型的键值，因此不适用于数组 三、for of 循环这是最简洁的循环数组的语法 避开了 for-in 的全部缺陷 与 forEach 不同的是，他可以正确的响应 break、continue、return 语句 for-of 循环支持数组循环，还支持字符串的循环 1234567var arr = [1,2,3,5,6];for(let val of arr)&#123; console.log(val) // 分别输出 1 2 3 5 6&#125;for(let val of "laoluo")&#123; console.log(val); //分别输出各个字符 l a o l u o&#125; 如果对象想使用 for of 可以通过定义对象的 Symbol.iterator 属性 12345678910111213141516171819202122232425262728 var selectedType = &#123; a: 1, b: 2&#125;Object.defineProperty(selectedType,Symbol.iterator,&#123; enumerable: false, writable: false, configurable: true, value: function()&#123; var o = this; var idx = 0; var ks = Object.keys(o); return&#123; next: function()&#123; return&#123; value: o[ks[idx++]], done: idx&gt;ks.length &#125; &#125; &#125; &#125; &#125;)for(var i of selectedType)&#123; console.log(i); &#125;// 1// 2 for-of 循环可以遍历其他集合（map， set）四、 Object.getOwnPropertyNames(obj) 遍历返回数组，包含自身对象的所有属性（不包含Symbol，但是包括不可枚举属性） 引用 https://www.infoq.cn/article/es6-in-depth-iterators-and-the-for-of-loop]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概念：浅拷贝-深拷贝]]></title>
    <url>%2F2018%2F12%2F05%2Fjavascript%2F%E6%A6%82%E5%BF%B5%EF%BC%9A%E6%B5%85%E6%8B%B7%E8%B4%9D-%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[概念：浅拷贝-深拷贝 浅拷贝，对于第一层目标对象为基本数据类型的数据，直接赋值，而对于引用数据类型，就是直接赋存在于栈内存的堆内存地址 ,即【传址】，并没有开辟新的栈 深拷贝，则为深度的赋值，里面对象对应两个var 三、深拷贝1.对象浅拷贝：(1) Object.assign({},yourObj); (2) var newObj = {…yourObj}; 2.对象深拷贝(1) JSON.parse(JSON.stringify(yourObject)) 后面再继续记录更多的方法 https://segmentfault.com/a/1190000015042902]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[717. 1-bit and 2-bit Characters]]></title>
    <url>%2F2018%2F12%2F05%2Fleetcode%2F717.%201-bit%20and%202-bit%20Characters%2F</url>
    <content type="text"><![CDATA[717. 1-bit and 2-bit Characters We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11). Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero. Example 1: 12345Input:bits = [1, 0, 0]Output: TrueExplanation:The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character. Example 2: 12345Input:bits = [1, 1, 1, 0]Output: FalseExplanation:The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character. Note: 1 &lt;= len(bits) &lt;= 1000. bits[i] is always 0 or 1. 解题思路: 由于只有三种编码方式 0 10 `11 所以只要遇到 1就会前进两格，当遇到0时则前进一格，令初始值为 i=0 如果最后一个为 0则倒数第二个数所积累的长度必然等于 length-1 123456789101112131415/** * @param &#123;number[]&#125; bits * @return &#123;boolean&#125; */var isOneBitCharacter = function(bits) &#123; var len = bits.length; var i = 0; while(i&lt;len-1)&#123; if(bits[i]=="1") i = i+2; else i++; &#125; return i == len-1&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[942. DI String Match]]></title>
    <url>%2F2018%2F12%2F05%2Fleetcode%2F942.%20DI%20String%20Match%2F</url>
    <content type="text"><![CDATA[942. DI String Match Given a string S that only contains “I” (increase) or “D” (decrease), let N = S.length. Return any permutation A of [0, 1, ..., N] such that for all i = 0, ..., N-1: If S[i] == &quot;I&quot;, then A[i] &lt; A[i+1] If S[i] == &quot;D&quot;, then A[i] &gt; A[i+1] Example 1: 12Input: &quot;IDID&quot;Output: [0,4,1,3,2] Example 2: 12Input: &quot;III&quot;Output: [0,1,2,3] Example 3: 12Input: &quot;DDI&quot;Output: [3,2,0,1] Note: 1 &lt;= S.length &lt;= 10000 S only contains characters &quot;I&quot; or &quot;D&quot;. 123456789101112131415161718/** * @param &#123;string&#125; S * @return &#123;number[]&#125; */var diStringMatch = function(S) &#123; var min = 0; var max = S.length; var s = S.split(""); var answer = s.map(function(item)&#123; if(item=="I")&#123; return min++; &#125;else if (item=="D")&#123; return max--; &#125; &#125;) answer.push(min); //因为最后只剩下一个数字 return answer;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript字符串操作+ 929. Unique Email Addresses]]></title>
    <url>%2F2018%2F12%2F05%2Fleetcode%2FJavaScript%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%2B%20929.%20Unique%20Email%20Addresses%2F</url>
    <content type="text"><![CDATA[JavaScript字符串操作+ 929. Unique Email AddressesEvery email consists of a local name and a domain name, separated by the @ sign. For example, in `alice@leetcode.com,aliceis the local name, andleetcode.com` is the domain name. Besides lowercase letters, these emails may contain &#39;.&#39;s or &#39;+&#39;s. If you add periods (&#39;.&#39;) between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. For example, &quot;alice.z@leetcode.com&quot; and &quot;alicez@leetcode.com&quot; forward to the same email address. (Note that this rule does not apply for domain names.) If you add a plus (&#39;+&#39;) in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered, for example `m.y+name@email.comwill be forwarded tomy@email.com`. (Again, this rule does not apply for domain names.) It is possible to use both of these rules at the same time. Given a list of emails, we send one email to each address in the list. How many different addresses actually receive mails? Example 1: 123Input: [&quot;test.email+alex@leetcode.com&quot;,&quot;test.e.mail+bob.cathy@leetcode.com&quot;,&quot;testemail+david@lee.tcode.com&quot;]Output: 2Explanation: &quot;testemail@leetcode.com&quot; and &quot;testemail@lee.tcode.com&quot; actually receive mails Note: 1 &lt;= emails[i].length &lt;= 100 1 &lt;= emails.length &lt;= 100 Each emails[i] contains exactly one &#39;@&#39; character. 以上大概的意思就是检测是否有重复的邮箱，local部分如果有符号.则忽视，+则后面全部东西进行忽略 考点: 对字符串的操作 12345678910111213141516var numUniqueEmails = function(emails) &#123; var uniq = []; for (var i = 0; i &lt; emails.length; i++) &#123; var emSplit = emails[i].split('@'); var local = emSplit[0].split('+')[0].replace(/\./g, '') + '@' + emSplit[1]; var domain = emSplit[1]; //includes 是ES6 Array的新方法，查找是否有元素 if (!uniq.includes(local)) &#123; uniq.push(local); &#125; &#125; return uniq.length;&#125;; 字符串操作一、slice、substring 、substr——截取字符串,但不修改字符串本身的值1.单个参数三种方法都一样，从开始位置进行截取 2.两个参数slice 、substring 截取开始和结束的 index（但不截取该位置字符） 而 substr 是开始索引 index 和 长度。 3. 参数出现负数当以上三种若参数中出现负数时，情况各不相同 slice 会将传入负值与字符串长度相加， substr 会将负数的第一个参数加上字符串长度，第二个参数若为负数则转换为 0 ， substring 会将所有负值参数转换 0 123456var value = "hello world" //共11位alert(value.slice(-3)); // rldalert(value.substring(-3)) // hello world 相当于 value.substring(0)alert(value.substr(-3)) // rldalert(value,slice(3,-4)) // lo walert(value.substring(3,-4)) //hel 相当于 value.substring(3,0); 注意：只有 substring 方法会将较小的数作为开始位置 1value.substring(3,1) 相当于 value.substring(1,3) 二、join() 和 split(),一个为连接数组，一个为拆分数组，括号内填写连接或者拆分的字符串。三、concat 拼接一个或多个字符串1234var value = "hello ";var result = value.concat("world","!");alert(result); //"hello world!"alert(value); //"hello" 数组操作一、拆分——slice 和 splice前者 slice 需要开始和结束索引，并返回一个子数组（但不改变原数组） splice 则需要开始索引和长度（会改变原数组），并返回一个子数组 slice 为浅拷贝， ​]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[比较运算符]]></title>
    <url>%2F2018%2F12%2F05%2Fjavascript%2F%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[比较运算符 数字 跟 字符串 比较， 会将字符串转换成数字进行比较 字符串 和 字符串 比较，会比较对应位置上的字符 unicode 编码值比较 123&apos;a&apos;&lt; &apos;b&quot; //true&apos;abcdd&apos;&lt;&apos;abcda&apos; //false&apos;2018-02-23&apos;&lt;&apos;2018-11-11&apos; //true 详细记录 https://www.jeffjade.com/2015/08/28/2015-09-02-js-string-compare/]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 背景图设置]]></title>
    <url>%2F2018%2F12%2F05%2Fcss%2FCSS3%20%E8%83%8C%E6%99%AF%E5%9B%BE%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[CSS3 背景图设置一、设置背景图background-image: url(&#39;/static/img/background.jpg&#39;); 二、设置背景图大小 三、设置其他属性集合1234background-repeat: repeat || repeat-x || repeat-y || no-repeat background-origin: content-box || padding-box || border-box;//规定背景图片的定位区域background-image: url(1.jpg),url(2.jpg);// 允许使用多个背景图片]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[53. Maximum Subarray（最大子串）——EASY]]></title>
    <url>%2F2018%2F12%2F05%2Fleetcode%2F53.%20Maximum%20Subarray%EF%BC%88%E6%9C%80%E5%A4%A7%E5%AD%90%E4%B8%B2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[53. Maximum Subarray（最大子串）——EASYGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: 123Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6. Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. 解题思路： 从前往后进行遍历，设置两个总和 maxSum 和 curSum 当加上当前值小于之前值时，则替换最大值为当前值。 其实简单来说： 从前往后遍历，需要两个变量，一个max 存储最大值，一个 lastMax 存储当前最大值， 开始给 max 赋值 nums[0] . lastMax = 0; 然后不断的给 lastMax 赋值，如果大于 max 则进行替换 max，否则不变。 然后保证每次循环检验 lastMax 是否小于 0 ，如果小于0，则说明前面数并没起到作用，所以抛弃，lastMax 从0 开始。 1234567891011121314151617var maxSubArray = function(nums) &#123; if(nums.length==0) return 0; var maxSum = nums[0], curSum = nums[0]; for(var i=1;i&lt;nums.length;i++)&#123; if(nums[i]&gt;curSum+nums[i])&#123; curSum = nums[i]; &#125;else&#123; curSum += nums[i]; &#125; if(curSum&gt;maxSum)&#123; maxSum = curSum; &#125; &#125; return maxSum;&#125;;console.log(maxSubArray([-2,1,-3,4,-1,2,1,-5,4])); 另外一种写法 1234567891011121314var maxSubArray = function(nums) &#123; var max = nums[0]; var lastMax = 0; for(let i=0;i&lt;nums.length;i++)&#123; lastMax += nums[i]; if(lastMax&gt;max)&#123; max = lastMax; &#125; if(lastMax&lt;0)&#123; lastMax = 0; &#125; &#125; return max;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器缓存知识记录]]></title>
    <url>%2F2018%2F01%2F08%2Fbrowser%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[浏览器缓存知识记录一、浏览器缓存基本知识浏览器的缓存机制有两种，一种为 强缓存， 另一种是 协商缓存 浏览器在请求资源之前会在 http 的 headers 中判断是否命中强缓存，如果命中浏览器就直接在自己的缓存中加载资源，不会发送请求到服务器。 如果强缓存没命中，浏览器会发送一个请求到服务器，服务器会根据状态码 二、强缓存原理 当浏览器对某个资源命中强缓存的时候，返回的状态码为 200 ，在chrome 的开发者工具的 network 里面 size 会显示 from cache(新版本的 chrome 改为 from disk cache/from memory cache) 强缓存主要是通过 expires 、cache-control 进行判断 1. Expires 是 http1.0 提出的一个表示资源过期时间的header它由服务器返回，描述的是一个终止的绝对时间，如： Expires:Thu, 31 Dec 2037 23:55:55 GMT 其原理是： 1） 第一次请求资源的时候，response 的header 会带有Expires 的headers; 2）浏览器会在接受到这资源后连同所有的 response header一起缓存下来（所以缓存命中的请求返回的header 并不是 来自服务器，而是来自之前的 缓存 header) 3) 浏览器再次请求该资源的时候，会从缓存中寻找是否有这个资源，然后拿出它的 Expires 和当前时间进行比较，如果该时间之前，就能命中缓存，否则不行 4）如果缓存没有命中，浏览器会直接从服务器加载资源，同时该资源的 Expires 在重新加载的时候将会更新 但是有个问题是，如果随意修改下客户端的时间，会印象缓存命中的结果，所以有了 cache-control 2. Cache-Control 是 http1.1 提出的一个新 header以秒为单位, 如 cache-control: max-age=3153600000 流程与上同，只是在判断的时候根据第一次请求的时间和Cache-Control 设定的有效期与当前时间进行比较。 上面两个 header 可以同时启用，也可只启用一个，但是 Cache-Control 的优先级高于 Expires 三、协商缓存原理协商缓存是利用 【Last-Modified, If-Modified-Since】（最后一次修改时间） 和 【ETag、If-None-Match】（资源的位移标识——字符串，只要资源变化就会修改） 这两对 Header 进行管理 第一次发送请求是响应body 带有 (Last-Modified / ETag) 浏览器再次发送请求资源时 会在 Header 中加上 If-Modified-Since/If-None-Match 的 header，这个值为上次请求返回的 Last-Modified/ ETag 。 服务器通过上述值 If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，相同则说明没有更改，则返回 304 Not Modified，并且在 response header 中不会再添加 Last-Modified 的 header ，因为既然资源没有变化，那么 Last-Modified 就不会改版；如果不相同（有变化），则返回正常资源内容。 当服务器接收到值 If-None-Match和然后再根据资源生成的一个新的 ETag 比较，如果两个值相同则说明两个资源没有变化， 如果没有变化则返回 304 Not Modified ，并且不返回资源，但和 If-Modified-Since不一样的是，ETag 重新生成过，所有response header 还是会把这个 ETag 返回，即使与原来相同。 浏览器如果收到304 响应，就会子啊缓存中加载资源 四、浏览器行为对缓存的影响浏览器以下的行为将会影响缓存： 1) 当 crtl + f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存 2) 当 f5 刷新页面的时候，跳过强缓存，但会检查协商缓存 引用： ​ https://www.cnblogs.com/chenqf/p/6386163.html]]></content>
      <categories>
        <category>browser</category>
      </categories>
      <tags>
        <tag>browser</tag>
      </tags>
  </entry>
</search>
